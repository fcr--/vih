initwtm %getcommand

/cursorup {getypos 0 gt {getypos 1 - setypos} if} def
/cursordown {getypos getysize 1 - lt {getypos 1 + setypos} if} def
/cursorleft {getxpos 0 gt {getxpos 1 - setxpos} if} def
/cursorright {
  getxpos
  getypos getline length % límite derecho es el largo...
      mode /normal eq {1 -} if % en modo normal no puedo ir tan a la derecha
  lt   {getxpos 1 + setxpos} if
} def
/cursoreol {getypos getline length setxpos} def

% - getliteralkey keystr
/getliteralkey {
  % TODO
} def

% location bindings are relative to symbols x, y, and these
% bindings must update those variables.
%   x may be equal to length of 'y getline'.
/locationbindings <<
  "h" {
    x 0 gt {/x x 1 - def} if
  }
  "j" {
    y  getysize 1 -  lt {/y y 1 + def} if
  }
  "k" {
    y 0 gt {/y y 1 - def} if
  }
  "l" {
    x  y getline length  lt  {/x x 1 + def} if
  }
  "b" {
    % TODO
  }
  "w" {
    % TODO
  }
  "e" {
    /eof 0 def /x2 x def /y2 y def
    /runnext {
      /line y getline def
      /x x 1 + dup line length gt {pop line length} if def
      ".*?\\w\\b"
      line x line length getinterval
      regexp dup 0 ge {
	exch pop % keep the top value, discard the other
	/x exch x + 1 - def
      } {
	pop
	% try with next line if it exists
	/x 0 def
	/y y 1 + def
	y getysize lt {runnext} {/eof 1 def} ifelse
      } ifelse
    } def
    runnext
    eof {
      % recover old values
      /x x2 def /y y2 def
    } if
  }
  "f" {
    /line y getline def
    /c getliteralkey def
    % ejecuto for(i=min(x,length(line)); i>=0; i--):
    x dup line length ge {pop line length 1 -} if
    -1 0 {
      /i exch def
      line i get c eq {/x i def exit} if % if (c==line[i]){x=i; break}
    } for
  }
  "t" {
    /line y getline def
    /x2 x 1 + dup line length gt {pop line length} if
    /line line x2  line length  getinterval
    line getliteralkey search {
      % stack: ... post match pre
      % x := x2 + length(pre):
      /x exch length x2 + def % stack: ... post match
      pop pop
    } if
  }
  "^" {
    /x 0 def
  }
  "$" {
    /x y getline length def
  }
>> def

/getlocationkey {
  % TODO
} def

% locationtypestr movelocation -
/movelocation {
  begin
    /x getxpos def /y getypos def
    dup locationbindings exch known {
      locationbindings exch get exec
      y setypos x setxpos
    } {pop} ifelse
  end
} def

/getlocation {[getxpos getypos]} def
/setlocation {exec setypos setxpos} def

%%%%%% DEFAULT KEYBINDINGS %%%%%%

/mode /normal def

/normalkeybindings <<
  {{"KUp"} {}} {
    cursorup
  }
  {{"KDown"} {}} {
    cursordown
  }
  {{"KLeft"} {}} {
    cursorleft
  }
  {{"KRight"} {}} {
    cursorright
  }
  {{"KEnter"} {}} {
    cursordown
    begin
      /x 0 def
      /line getypos getline def
      /len line length def
      {
	x len ge {exit} if % si x>=len break loop
	line x get " " ne {exit} if % si line[x]!=" " break loop
	/x x 1 + def
      } loop
      x setxpos
    end
  }
  {{"KBS"} {}} {
    % estoy al comienzo de la línea?
    getxpos 0 eq {
      getypos 0 gt {cursorup cursoreol} if
    } {
      cursorleft
    } ifelse
  }
  {{"KASCII" ":"} {}} {
    getcommand
    {interpcommand} if
  }
  {{"KASCII" "$"} {}} {
    cursoreol % moverse al fin de línea
  }
  {{"KASCII" "A"} {}} {
    % mode insert al final de la línea
    /mode /insert store % cambio modo insert
    getypos getline length setxpos % voy al fin de línea
  }
  {{"KASCII" "a"} {}} {
    % mode insert a la derecha
    /mode /insert store % cambio modo insert
    getxpos 1 + setxpos
  }
  {{"KASCII" "e"} {}} {
    "e" movelocation
  }
  {{"KASCII" "h"} {}} {
    cursorleft
  }
  {{"KASCII" "I"} {}} {
    % mode insert
    /mode /insert store
    0 setxpos
  }
  {{"KASCII" "i"} {}} {
    % mode insert
    /mode /insert store
  }
  {{"KASCII" "J"} {}} {
    % join lines
    getypos getysize 1 - lt {
      getypos
      getypos getline " " +
      getypos 1 + getline +
      setline
      % delete old next line:
      getypos 1 + deleteline
    } if
  }
  {{"KASCII" "j"} {}} {
    cursordown
  }
  {{"KASCII" "k"} {}} {
    cursorup
  }
  {{"KASCII" "l"} {}} {
    cursorright
  }
  {{"KASCII" "O"} {}} {
    0 openline
    /mode /insert store
  }
  {{"KASCII" "o"} {}} {
    1 openline
    /mode /insert store
  }
  % TODO
>> def

/insertkeybindings <<
  {{"KUp"} {}} {
    cursorup
  }
  {{"KDown"} {}} {
    cursordown
  }
  {{"KLeft"} {}} {
    cursorleft
  }
  {{"KRight"} {}} {
    cursorright
  }
  {{"KEnter"} {}} {
    begin
      /line getypos getline def
      /len line length def
      /x getxpos dup len gt {pop len} if def % if (xpos>len)xpos = len
      1 openline
      % set the text behind the cursor in the current line:
      getypos 1 -
	line 0 x getinterval
      setline
      % set the text after the cursor to the new line:
      getypos
	line x  len x -  getinterval
      setline
      0 setxpos
    end
  }
  {{"KBS"} {}} {
    % estoy al comienzo de la línea?
    getxpos 0 eq {
      getypos 0 gt { % solo actúo si no estoy en la primer línea.
	begin
	  /yp getypos 1 - def
	  /lp yp getline def
	  yp
	    lp  getypos getline + % uno la línea previa y la actual
	  setline
	  deleteline
	  yp setypos
	  lp length setxpos % ubico el cursor al final de la línea previa.
	end
      } if
    } {
      % hay texto a la izquierda, simplemente borro
      /line getypos getline def
      /len line length def
      /x getxpos dup len gt {pop len} if def % if (xpos>len)xpos = len
      getypos
	line 0  x 1 -  getinterval
	line x  len x -  getinterval + % concat from x, len-x chars.
      setline
      x 1 - setxpos
    } ifelse
  }
  % TODO
>> def

/interpcommand {
  [] exch " " search {
    % caso true, queda en stack: post match pre
    exch pop exch % stack: pre post
    [ exch ] % stack: [] pre [post]
    3 2 roll % stack: pre [post] []
    exch +   % stack: pre [post]
    exch     % stack: [post] pre
  } if
  % stacks ejemplo: {} ":q", {"archivo"} ":w"
  <<
    ":q" {quit}
    % TODO
  >> exch
  2 copy known {
    get exec % está presente, utilizo los 2 originales en get
  } {
    pop pop pop % descartamos los 2 originales recién copiados y param extra.
  } ifelse
} def

%%%%%% MAIN LOOP %%%%%%:

{
  %exit % descomente para ir a terminal de postscript.
  [ getkey ]
  % stack: [key mods]
  mode /normal eq {
    dup normalkeybindings exch known {
      % si está en el diccionario lo ejecuta:
      normalkeybindings exch get exec
    } {pop} ifelse
  } {
    mode /insert eq {
      dup 0 get 0 get % stack: [key mods]
      "KASCII" eq {
	begin
	  dup 0 get 1 get % stack: [key mods] char
	  /char exch def
	  /line getypos getline def
	  /len line length def
	  /x getxpos dup len gt {pop len} if def % if (xpos>len)xpos = len
	  getypos
	  line 0 x getinterval
	  char +
	  line x  len x -  getinterval + % concat from x, len-x chars.
	  setline
	  x 1 + setxpos
	end
	% stack: [key mods] key
      } if
      dup insertkeybindings exch known {
	% si está en el diccionario lo ejecuta:
	dup insertkeybindings exch get exec
      } if
      dup 0 get 0 get "KEsc" eq {
	/mode /normal store
	cursorleft
      } if
      % stack: [key mods]
    } if % Add other modes, TODO
    pop
  } ifelse % mode /normal eq
} loop
