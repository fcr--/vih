initwtm %getcommand

/cursorup {getypos 0 gt {getypos 1 - setypos} if} def
/cursordown {getypos getysize 1 - lt {getypos 1 + setypos} if} def
/cursorleft {getxpos 0 gt {getxpos 1 - setxpos} if} def
/cursorright {
  getxpos
  getypos getline length % límite derecho es el largo...
      mode /normal eq {1 -} if % en modo normal no puedo ir tan a la derecha
  lt   {getxpos 1 + setxpos} if
} def
/cursoreol {getypos getline length setxpos} def
/cursorbol {
  begin
    /x 0 def
    /line getypos getline def
    /len line length def
    {
      x len ge {exit} if % si x>=len break loop
      line x get " " ne {exit} if % si line[x]!=" " break loop
      /x x 1 + def
    } loop
    x setxpos
  end
} def

% msgname msg msgstring
/msg {
  dup chosen_messages exch known {
    chosen_messages exch get
  } {
    messages_en exch get
  } ifelse
} def

% - getliteralkey keystr
/getliteralkey {
  % TODO
} def

% location bindings are relative to symbols x, y, and these
% bindings must update those variables.
%   x may be equal to length of 'y getline'.
/locationbindings <<
  "h" {
    x 0 gt {/x x 1 - def} if
  }
  "j" {
    y  getysize 1 -  lt {/y y 1 + def} if
  }
  "k" {
    y 0 gt {/y y 1 - def} if
  }
  "l" {
    x  y getline length 1 -  lt  {/x x 1 + def} if
  }
  "b" {
    % TODO
  }
  "w" {
    % TODO
  }
  "e" {
    /runnext {
      /line y getline def
      /x x 1 + dup line length gt {pop line length} if def
      ".*?\\w\\b"
      line x line length getinterval
      regexp dup 0 ge {
	exch pop % keep the top value, discard the other
	/x exch x + 1 - def
      } {
	pop
	% try with next line if it exists
	/x 0 def
	/y y 1 + def
	y getysize lt {runnext} {/move 0 def} ifelse
      } ifelse
    } def
    runnext
  }
  "f" {
    /line y getline def
    /c getliteralkey def
    /move 0 def
    % ejecuto for(i=min(x,length(line)); i>=0; i--):
    x dup line length ge {pop line length 1 -} if
    -1 0 {
      /x exch def
      line i get c eq {/move 1 def exit} if % if (c==line[i]){x=i; break}
    } for
  }
  "t" {
    /line y getline def
    /x2 x 1 + dup line length gt {pop line length} if
    /line line x2  line length  getinterval
    line getliteralkey search {
      % stack: ... post match pre
      % x := x2 + length(pre):
      /x exch length x2 + def % stack: ... post match
      pop pop
    } {pop /move 0 def} ifelse
  }
  "^" {
    /x 0 def
  }
  "$" {
    /x y getline length def
  }
>> def

/getlocationkey {
  % TODO
} def

% locationtypestr movelocation -
/movelocation {
  begin
    /x getxpos def /y getypos def
    /move 1 def
    dup locationbindings exch known {
      locationbindings exch get exec
      move {y setypos x setxpos} if
    } {pop} ifelse
  end
} def

/getlocation {[getxpos getypos]} def
/setlocation {exec setypos setxpos} def

%%%%%% DEFAULT KEYBINDINGS %%%%%%

/mode /normal def

/normalkeybindings <<
  {{"KUp"} {}} {
    cursorup
  }
  {{"KDown"} {}} {
    cursordown
  }
  {{"KLeft"} {}} {
    cursorleft
  }
  {{"KRight"} {}} {
    cursorright
  }
  {{"KEnter"} {}} {
    cursordown
    cursorbol
  }
  {{"KBS"} {}} {
    % estoy al comienzo de la línea?
    getxpos 0 eq {
      getypos 0 gt {cursorup cursoreol} if
    } {
      cursorleft
    } ifelse
  }
  {{"KASCII" ":"} {}} {
    ":" getcommand
    {interpcommand} if
  }
  {{"KASCII" "^"} {}} {
    cursorbol
  }
  {{"KASCII" "$"} {}} {
    cursoreol % moverse al fin de línea
  }
  {{"KASCII" "A"} {}} {
    % mode insert al final de la línea
    /mode /insert store % cambio modo insert
    getypos getline length setxpos % voy al fin de línea
    /insert_mode msg setst showwtm
  }
  {{"KASCII" "a"} {}} {
    % mode insert a la derecha
    /mode /insert store % cambio modo insert
    getxpos 1 + setxpos
    /insert_mode msg setst showwtm
  }
  {{"KASCII" "e"} {}} {
    "e" movelocation
  }
  {{"KASCII" "h"} {}} {
    cursorleft
  }
  {{"KASCII" "I"} {}} {
    % mode insert
    /mode /insert store
    /insert_mode msg setst showwtm
    cursorbol
  }
  {{"KASCII" "i"} {}} {
    % mode insert
    /mode /insert store
    /insert_mode msg setst showwtm
  }
  {{"KASCII" "J"} {}} {
    % join lines
    getypos getysize 1 - lt {
      getypos
      getypos getline " " +
      getypos 1 + getline +
      setline
      % delete old next line:
      getypos
      getypos 1 + setypos deleteline
      setypos
    } if
  }
  {{"KASCII" "j"} {}} {
    cursordown
  }
  {{"KASCII" "k"} {}} {
    cursorup
  }
  {{"KASCII" "l"} {}} {
    cursorright
  }
  {{"KASCII" "O"} {}} {
    0 openline
    /mode /insert store
    /insert_mode msg setst showwtm
  }
  {{"KASCII" "o"} {}} {
    1 openline
    /mode /insert store
    /insert_mode msg setst showwtm
  }
  % TODO
>> def

/insertkeybindings <<
  {{"KUp"} {}} {
    cursorup
  }
  {{"KDown"} {}} {
    cursordown
  }
  {{"KLeft"} {}} {
    cursorleft
  }
  {{"KRight"} {}} {
    cursorright
  }
  {{"KEnter"} {}} {
    begin
      /line getypos getline def
      /len line length def
      /x getxpos dup len gt {pop len} if def % if (xpos>len)xpos = len
      1 openline
      % set the text behind the cursor in the current line:
      getypos 1 -
	line 0 x getinterval
      setline
      % set the text after the cursor to the new line:
      getypos
	line x  len x -  getinterval
      setline
      0 setxpos
    end
  }
  {{"KBS"} {}} {
    % estoy al comienzo de la línea?
    getxpos 0 eq {
      getypos 0 gt { % solo actúo si no estoy en la primer línea.
	begin
	  /yp getypos 1 - def
	  /lp yp getline def
	  yp
	    lp  getypos getline + % uno la línea previa y la actual
	  setline
	  deleteline
	  yp setypos
	  lp length setxpos % ubico el cursor al final de la línea previa.
	end
      } if
    } {
      % hay texto a la izquierda, simplemente borro
      /line getypos getline def
      /len line length def
      /x getxpos dup len gt {pop len} if def % if (xpos>len)xpos = len
      getypos
	line 0  x 1 -  getinterval
	line x  len x -  getinterval + % concat from x, len-x chars.
      setline
      x 1 - setxpos
    } ifelse
  }
  % TODO
>> def

/interpcommand {
  [] exch " " search {
    % caso true, queda en stack: post match pre
    exch pop exch % stack: pre post
    [ exch ] % stack: [] pre [post]
    3 2 roll % stack: pre [post] []
    exch +   % stack: pre [post]
    exch     % stack: [post] pre
  } if
  % stacks ejemplo: {} ":q", {"archivo"} ":w"
  <<
    ":q" {getbuffsize {closewin} {quit} ifelse}
    ":e" {dup {} eq {{""} +} if exec openfile}
    ":w" {writefile}
    % TODO
  >> exch
  2 copy known {
    get exec % está presente, utilizo los 2 originales en get
  } {
    pop pop pop % descartamos los 2 originales recién copiados y param extra.
  } ifelse
} def

/parseargs {
  begin
    /prev "" def
    /args load {
      /opt exch def
      /cont 0 def
      % -s file:
      prev "-s" eq {
	/cont 1 def
	opt run
      } if
      cont not  opt "-s" eq and {/cont 1 def} if
      % --help / -h
      cont not  opt "--help" eq opt "-h" eq or and {
	/cont 1 def
	0 /options msg setline
	% TODO check for new file
      } if
      % otherwise load file:
      cont not {
	% TODO openfile (creating new window)
      } if
      % the only supported option is -s to load a script:
      /prev opt def
    } forall
  end
} def

%%%%%% MAIN LOOP %%%%%%:

parseargs

showwtm

{
  %exit % descomente para ir a terminal de postscript.
  [ getkey ]
  % stack: [key mods]
  mode /normal eq {
    dup normalkeybindings exch known {
      % si está en el diccionario lo ejecuta:
      normalkeybindings exch get exec
    } {pop} ifelse
  } {
    mode /insert eq {
      dup 0 get 0 get % stack: [key mods]
      "KASCII" eq {
	begin
	  dup 0 get 1 get % stack: [key mods] char
	  /line getypos getline def
	  /len line length def
	  /x getxpos dup len gt {pop len} if def % if (xpos>len)xpos = len
	  /char exch
	    % "\t" exception: move cursor to multiple of shift_width:
	    dup "\t" eq {
	      % add shift_width - (x `mod` shift_width) spaces
	      pop "" 1 1 shift_width x shift_width mod - {pop " " +} for
	    } if
	    def
	  getypos
	  line 0 x getinterval
	  char +
	  line x  len x -  getinterval + % concat from x, len-x chars.
	  setline
	  x char length + setxpos
	end
	% stack: [key mods] key
      } if
      dup insertkeybindings exch known {
	% si está en el diccionario lo ejecuta:
	dup insertkeybindings exch get exec
      } if
      dup 0 get 0 get "KEsc" eq {
	/mode /normal store
	"" setst showwtm
	cursorleft
      } if
      % stack: [key mods]
    } if % Add other modes, TODO
    pop
  } ifelse % mode /normal eq
} loop
